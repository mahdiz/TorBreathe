%\subsubsection{Fully Load-Balanced Algorithm}
%\todo{So far, we have assumed the number of users in each column of $M$ is fixed and the same for all columns. This allows us to achieve the highest level of load-balancing as each bridge is assigned to exactly the same number of users. However in the rest of this section, we show that by slightly relaxing the load-balancing requirement, not only can we remove the ${t=\alpha n}$ constraint of Lemma~\ref{lem:azumaMatrix}, but also reduce the number of bridges required. To this end, we run Algorithm~\ref{alg:Basic} with a modified version of \alg{Distribute} as defined in Algorithm~\ref{alg:DistributeLB}.}
%
%In each run of~\alg{Distribute}, an $\frac{n}{d_i}$-by-$d_i$ matrix is created and each user in $U$ is randomly assigned to one of the elements of the matrix such that all users appear in the matrix and each user appears exactly once. The random assignment of users is done using a random permutation $\pi$ that maps every integer between $1$ and $n$ (corresponding to every element of the matrix) to an integer between $1$ and $n$ (corresponding to every user index).
%
%Next, the algorithm recruits a set of $w$ unblocked bridges and assigns a unique bridge to all users in each column of the matrix. To improve the efficiency of our algorithm in practice, we assume the bridges that were recruited in previous rounds and remain unblocked are reused for distribution in the next round.
%
%\begin{algorithm}[t]
%	\caption{Fully Load-Balanced \alg{Distribute}}
%	\label{alg:DistributeLB}
%	
%	\algFont \vspace{5pt}
%	\textit{Goal:} A sequence of $d_i$ bridges is randomly distributed among a set of $n$ users ${U = \{u_1,...,u_n\}}$.\vspace{0.3em}
%	\begin{algorithmic}[1]
%		\Function{Distribute}{$U, d_i$}
%		\State $B_i \gets$ a sequence of $d_i$ unblocked bridges \label{ln:recruitBridges}
%		\State Define a matrix $M = \left[u_{\pi\left(i+(j-1)\frac{n}{d_i}\right)}\right]_{\frac{n}{d_i}\times d_i}$ such 
%		\Statex \hspace{\algorithmicindent}that $\pi:[n]\to[n]$ is a random permutation \label{ln:defMatrices}
%		\ForAll{$j \in [d_i]$}
%		\State Assign $B_i[j]$ to users in $j$-th column of $M$ \label{ln:assignColumns}
%		\EndFor
%		\State \Return $B_i$
%		\EndFunction
%	\end{algorithmic}
%\end{algorithm}
%Figure~\ref{fig:matrices} shows the matrix generated in each execution of Algorithm~\ref{alg:DistributeLB}. In this figure, ${\pi:[n]\to[n]}$ refers to the random permutation generated in line~\ref{ln:defMatrices} of the algorithm, and $B$ refers to the sequence of $w$ bridges being assigned to the users in the current run of the algorithm.
%
%\begin{figure}[!t]
%	\centering
%	\includegraphics[width=0.7\linewidth]{images/matrices}
%	\caption{Matrices generated by Algorithm~\ref{alg:DistributeLB} in round $i$}
%	\label{fig:matrices}
%\end{figure}
%
%\begin{lemma} \label{lem:WhpMatrix}
%	Let Algorithm~\ref{alg:Basic} call the modified version of \alg{Distribute} defined in Algorithm~\ref{alg:DistributeLB}. Then, Algorithm~\ref{alg:Basic} guarantees that all honest users can connect to Tor with high probability after ${\lceil \log{t} \rceil + 1}$ rounds, and the total number of bridges used is at most ${(8t - 2)c\log{n}}$.
%\end{lemma}
%\begin{proof}
%	Since the $n$ users are arranged uniformly and independently at random in $M$, and there are $t_i$ active corrupt users among them, the probability that for a given user $u$ the column that $u$ appears in contains at least one corrupt user is at most
%	\[1 - \left(\frac{n-t_i}{n}\right)^{\nicefrac{n}{d_i}} = 1 - \left(1-\frac{t_i}{n}\right)^{\nicefrac{n}{d_i}} \leq \frac{t_i}{d_i}.\]
%	The last inequality is correct based on the Bernoulli's inequality when ${t_i \leq d_i}$. If ${b_i < 2^i}$, then ${t_i < 2^i}$ because in each round each corrupt user appears in exactly one column in $M$, and thus can block at most one bridge. Since in each round ${d_i = 2^{i+1} \geq 2t_i}$, this probability becomes a constant ${\leq 1/2}$.
%	
%	Since Algorithm~\ref{alg:Basic} is repeated $c\log{n}$ times, the probability that every column that $u$ appears in among all matrices is ``bad'' (\ie, has at least one active corrupt user) is at most ${(1/2)^{c\log{n}} = 1/n^c}$.
%	By applying the union bound, the probability that any of the $n$ users fails to sit in a ``good'' column (\ie, a column with no active corrupt user) is at most $1/n^{c-1}$. Therefore for any ${c > 1}$, all honest users can connect to Tor with high probability.
%	
%	Similar to Lemma~\ref{lem:NumIterationsBasic}, we let $k$ denote the smallest number of rounds needed until all users can connect to Tor with high probability. $k$ is bounded, because $t$ is bounded. So, for all ${i \geq k}$, ${b_i < 2^i}$, and based on Lemma~\ref{lem:WhpMatrix}, all users can connect to Tor with high probability. We now find $k$ with respect to $t$. 
%
%	In each round $i$, the adversary can maximize $k$ by minimizing the number of bridges blocked (\ie, $b_i$), while ensuring the algorithm proceeds to the next round. This can be done by blocking only half of the $2^{i+1}$ bridges distributed in each round and memorizing the rest $2^{i}$ bridge addresses to be blocked in future rounds, where ${t < 2^i}$. Let $\ell$ be the smallest integer such that ${t \leq 2^\ell}$.
%	Until round $\ell$, the adversary can memorize at most 
%	\[\sum_{j=1}^{\ell-1} 2^j = 2^{\ell} - 2\] 
%	bridges. In round $\ell$, no more bridges can be memorized, because the adversary has to block all of the ${t \leq 2^\ell}$ bridges it has learned in this round to force the algorithm to proceed to round ${\ell + 1}$.  In round ${\ell + 1}$, however, the adversary can block at most 
%	\[2^\ell - 2 + 2^\ell = 2^{\ell+1} - 2 < 2^{\ell+1}\] 
%	bridges, which is insufficient for proceeding to round ${\ell + 2}$. Therefore, ${\ell + 1}$ is the last round and ${k = \ell + 1}$. Since ${t \leq 2^\ell}$, ${k = \lceil \log{t} \rceil + 1}$. In other words, if the algorithm is run for at least ${\lceil \log{t} \rceil + 1}$ iterations, then all honest users succeed with high probability.		
%	Finally, similar to Lemma~\ref{lem:NumBridgesBasic}, the total number of bridges can be calculated from~\eqref{eq:NumBridges} which is at most ${(8t - 2)c\log{n}}$.		
%	%	our choice of $d_i = 2^i$ in line~\ref{ln:DistributeSimple} of Algorithm~\ref{alg:Basic}, will eventually Since $c > 1$, it is sufficient to have $w_k \geq 2t_k$. Since the adversary's budget is bounded and $\frac{b_i}{ic\log{n}}$ is monotonically increasing, there exists some integer $k>0$ such that
%	%	\[t_k \leq \frac{b_k}{kc\log{n}}.\]
%	%	With our choice of $d_i = 2^i$ in line~\ref{ln:DistributeSimple} of Algorithm~\ref{alg:Basic}, we have
%	%	\[t_k \leq \frac{b_k}{kc\log{n}} < \frac{k2^kc\log{n}}{kc\log{n}} = 2^k = w_k,\]
%	%	which satisfies the condition $t_k < w_k$.
%\end{proof}

%In the following lemma, we use martingales to show that the number of bridges used by the algorithm can be reduced by a factor of two when only a constant fraction of the users are corrupted, \ie, when ${t = \alpha n}$, for some constant ${\alpha \in [0,1]}$. To achieve this, we let Algorithm~\ref{alg:Basic} distribute only ${d_i = 2^i}$ bridges in each round.
%
%\begin{lemma} \label{lem:azumaMatrix}
%	Let only a fixed constant fraction of the users be corrupted, and ${d_i = 2^i}$ in each round $i$ of Algorithm~\ref{alg:Basic}. The algorithm guarantees all honest users can connect to Tor with high probability, and the total number of bridges used is ${(8t - 2)c\log{n}}$.
%\end{lemma}
%\begin{proof}
%	For $j=1,2,...,d_i$, let $\{X_j\}$ be a sequence of random variables each corresponding to the $j$-th column of $M$, where each column consists of $\frac{n}{d_i}$ users chosen uniformly at random without replacement from the set of all users. Also, let $Y$ be a random variable corresponding to the number of columns that have no corrupt users. Since $\E[|Y|] < \infty$, the sequence $\{Z_j = \E[Y|X_1,...,X_j]\}$ defines a Doob martingale. Since the probability that a given column has no corrupt user is at least $\left((n-t_i)/n\right)^{n/d_i}$, by the linearity of expectation, \[\E[Y] = d_i \cdot \left(1-\frac{t_i}{n}\right)^{\nicefrac{n}{d_i}}.\]
%	Since in each round ${d_i = 2^i \geq t_i}$ and ${t = \alpha n}$, for some constant ${\alpha \in [0,1]}$, we have ${\E[Y] = d_i(1-\alpha)^{1/\alpha}}$. This means that, in expectation, a constant fraction of the columns in each matrix (in each round) are good.
%	Since choosing one random column changes the expected number of good columns by at most one, ${|Z_{j+1} - Z_j| \leq 1}$. Using the Azuma's inequality, we get 
%	\[\Pr\left(|Y-\E[Y]|\right) \geq \lambda) \leq 2e^{\nicefrac{-2\lambda^2}{d_i}},\] 
%	for any ${\lambda > 0}$.
%	Therefore, the actual values of $Y$ are highly concentrated around its expected value $\E[Y]$.
%	
%	The number of bridges distributed in each round of the modified algorithm is ${d_i=2^i}$. Thus, using equation~\eqref{eq:NumBridges} in Lemma~\ref{lem:NumBridgesBasic}, the total number of bridges used by the modified algorithm is at most ${(8t - 2)c\log{n}}$.
%\end{proof}

%	For any $i \leq k$, consider the algorithm in three consecutive rounds $i - 1$, $i$, and $i+1$ as shown in Figure~\ref{fig:rounds}. In round $i-1$, the algorithm proceeds to line~\ref{ln:ConditionSimple}, where only one of the following two cases is possible:
%	\begin{enumerate}
%		\item \label{case:whp} $b_{i-1} < 2^{i-1}$: Based on Lemma~\ref{lem:whpSimple}, all honest users can connect to Tor with high probability.
%		
%		\item $b_{i-1} \geq 2^{i-1}$: The algorithm proceeds to the next round (round $i$) and distributes $w_{i} = 2^{i+1}$ bridges. Consider the following two possible cases:
%		\begin{enumerate}
%			\item $i < k$: In order for the algorithm to proceed to the next round, the adversary has to block at least $2^i$ bridges, otherwise Case~\ref{case:whp} happens and all honest users can connect to Tor with high probability. The adversary can memorize the remainder at most $2^i$ bridge addresses to block in future rounds.
%			
%			\item $i = k$: Since this is the last round, the adversary can only block less than half of the $2^{k+1}$ bridges distributed in this round. In fact, it can block at most $t$ bridges learned from the current round as well as \[\sum_{j=1}^{k-2} 2^j = 2^{k-1} - 2\] bridges learned (but not blocked) from the previous rounds. Therefore, we find $k$ sufficiently large such that $2^k > t + 2^{k-1} - 2$. This results in $k > \log{(t-2)} + 1$.
%		\end{enumerate}
%	\end{enumerate}
%	Thus, if the algorithm is run for at least $\lfloor\log{(t-2)}\rfloor + 2 = O(\log{t})$ iterations, then with high probability all honest users are guaranteed to be able to connect to Tor.

%\subsection{Detection Scheme} \label{sec:Fixed}
%In this section, we describe a technique for detecting and blacklisting corrupt users which allows us to reduce the number of bridges used by the algorithm from $O(t\log{n})$ to $O(t)$.
%
%\begin{algorithm}[H]
%	\caption{Bridge Distribution with Detection Scheme}
%	\label{alg:MainFixed}
%	
%	\vspace{2pt}
%	\algFont \vspace{5pt}
%	\begin{algorithmic}[1]
%		\State Initialize parameters: $c > 0$; $i \gets 1$; $U \gets$ a set of users $\{u_1,...,u_{n}\}$
%		\State \Call{Distribute}{$2,c,U$} %\Comment{Distribute $2c\log{n}$ real bridges}
%		\State \Call{DistributeFakes}{$c,U$} %\Comment{Distribute $nc\log{n}$ fake bridges}
%		
%		\While{\True}
%		\State $b_i \gets$ number of real bridges blocked so far %\Comment{Using~\cite{Ensafi:2014:DIP:2722265.2722279}}
%		
%		\State From $U$, delete every user whom any of the fake 
%		\Statex \hspace{\algorithmicindent}bridges assigned to it is blocked
%		\If {$b_i \geq i2^ic\log{n}$} \label{ln:ConditionFixed}
%		\State $i \gets i+1$ \label{ln:IncrementFixed}  %\Comment{Proceed to the next round}
%		\State \Call{Distribute}{$2^i,c,U$} \label{ln:DistributeFixed} %\Comment{Distribute $2^ic\log{n}$ real bridges}
%		\State \Call{DistributeFakes}{$c,U$} %\Comment{Distribute $nc\log{n}$ fake bridges}
%		\EndIf
%		\EndWhile
%	\end{algorithmic}
%\end{algorithm}
%
%\begin{algorithm}
%	\caption{Fake Bridge Distribution}
%	\label{alg:DistFakes}
%	
%	\algFont \vspace{5pt}
%	\textit{Goal:} A set of $nc\log{n}$ fake bridges is distributed among a set of $n$ users $U = \{u_1,...,u_n\}$.
%	\begin{algorithmic}[1]
%		\Function{DistributeFakes}{$U$}
%		\State Initialize parameter: $n \gets |U|$; $F \gets$ a list of 
%		\Statex \hspace{\algorithmicindent}$cn\log{n}$ unblocked fake bridges
%		\ForAll{$j \in [n]$} %\Comment{Assign $c\log{n}$ fake bridges to each user}
%		\State Assign $F[(j-1)c\log{n} + 1],...,F[jc\log{n}]$ to $u_j$
%		\EndFor
%		\EndFunction
%	\end{algorithmic}
%\end{algorithm}
%
%\subsubsection{Analysis of Algorithm~\ref{alg:MainFixed}} \label{sec:ProofFixed}
%
%PAGES 47-50 OF THE HANDNOTES

%\subsection{Sublinear Bridge Cost}
%In Algorithm~\ref{alg:MainFixed}, we assume each iteration is either successful or unsuccessful. Then, we show that $O(t\log{t}\log{n})$ bridges are needed to ensure that we get at least one successful iteration among $O(\log{t})$ iterations. Unfortunately, this algorithm and the corresponding analysis do not consider the number of honest users whom have been assigned at least one unblocked bridge even in unsuccessful iterations. In this section, we introduce a slightly modified model, where at the beginning of the algorithm, each user is holding one message to send to Tor. The goal is to guarantee that at the end of the algorithm, each user is given at least one chance to send its message to Tor. In other words, we guarantee that each user is given at least one unblocked bridge before the algorithm terminates.
%
%\begin{algorithm}[H]
%	\caption{Bridge Distribution Scheme}
%	\label{alg:MainFinal}
%	
%	\algFont \vspace{2pt}
%	\begin{algorithmic}[1]
%		\State Initialize parameters: $c > 0$; $i \gets 1$; $U \gets$ a set of users $\{u_1,...,u_{n_i}\}$; $n_i \gets |U|$
%		\State \Call{Distribute}{$2,c, U$} %\Comment{Distribute $2c\log{n}$ unblocked bridges}
%		\While{$n_i > 0$}
%		\State $b_i \gets$ number of bridges blocked so far %\Comment{Using~\cite{Ensafi:2014:DIP:2722265.2722279}}
%		
%		\If {$b_i \geq i2^ic\log{n_i}$} \label{ln:ConditionFinal}
%		\State $i \gets i+1$ \label{ln:IncrementFinal} %\Comment{Proceed to the next round}
%		\ForAll{$k \in [c\log{n}]$}
%		\State \Call{DistributeSingles}{$2^i, c, U$} \label{ln:DistributeFinal} %\Comment{Distribute $2^ic\log{n}$ unblocked bridges}
%		\EndFor
%		\EndIf
%		\State From $U$, remove the users that have successfully sent their message
%		\State $n_i \gets |U|$ %\Comment{Update the number of users}			
%		\EndWhile
%	\end{algorithmic}
%\end{algorithm}
%
%\begin{algorithm}
%	\caption{Randomized Real/Fake Bridge Distribution}
%	\label{alg:DistributeFinal}
%	
%	\algFont \vspace{5pt}
%	\textit{Goal:} A set of $w$ real bridges and $n$ fake bridges is randomly distributed among a set of $n$ users $U = \{u_1,...,u_n\}$.
%	\begin{algorithmic}[1]
%		\Function{DistributeSingles}{$w,c,U$}
%		\State Initialize parameter: $n \gets |U|$; $B \gets$ a list of $wc\log{n}$ unblocked bridges \label{ln:recruitBridgesFinal}
%		\State Define a matrix $M$ with $w$ columns and $\frac{n}{w}$ rows such that for all $i \in [\frac{n}{w}]$ and $j \in [w]$, we
%		\Statex \hspace{\algorithmicindent}have $M_{i,j} = [u_{j + (i-1)w}]$. \label{ln:defMatricesFinal}
%		
%		\State $r \gets$ a sequence of $\Theta(n\log{n})$ bits chosen uniformly and independently at random
%		\State $M \gets$ \alg{Shuffle($r, M$)}
%		\ForAll{$j \in [w]$}
%		\ForAll{$i \in [\frac{n}{w}]$}
%		\State $x \gets$ a value chosen randomly from $[0,1]$
%		\If{$x \leq p$}
%		\State Assign $B[j + (k-1)w]$ to the user in $M_{i,j}$ 	\label{ln:assignColumnsFinal}
%		\Else
%		\State Assign a fake bridge to the user in $M_{i,j}$
%		\EndIf
%		\EndFor
%		\EndFor
%		\EndFunction
%	\end{algorithmic}
%\end{algorithm}
%
%\subsection{Analysis of Algorithm~\ref{alg:MainFinal}} \label{sec:ProofFinal}
%PAGES 55-58 OF THE HANDNOTES

%\subsubsection{Honeypot Bridges}
%In this section, we describe a simple mechanism by which we can reduce the total number of unique bridges distributed by Algorithm~\ref{alg:Basic} by a logarithmic factor. Although we have assumed our algorithm has access to a reliable supply of bridges, recruiting new bridges is expensive and the algorithm should pay a reasonable cost for bridges comparing to the cost that the adversary pays for blocking them. 
%
%%Remember that Algorithm~\ref{alg:Basic} distributes $2^ic\log{n}$ bridges in each round $i$. 
%Our idea is to distribute only half of the bridges distributed by Algorithm~\ref{alg:Basic} in each round and instead distribute \emph{fake} bridges, which we refer to as \emph{honeypot bridges}, as the other half. Intuitively, if the adversary cannot distinguish between real and honeypot bridges, then this will force him to spend at least half of his budget in expectation in blocking fake bridges.
%
%By assigning unique fake bridges to each user, we can detect corrupt users by finding the intersection between  on the bridges blocked Intuitively, , 
%algorithm can still success 
%To this end, we introduce the notion of \emph{honeypot bridges} which are legitimate-looking fake bridges that are distributed along with \emph{real bridges} for detecting corrupt users. Similar to real bridges, we assume every honeypot bridge is identified by an IP/port address, and it is \emph{hard} for the adversary to distinguish it from a real bridge. In the following, we describe a mechanism by which the 


	%	For any $i \leq k$, consider the algorithm in three consecutive rounds $i - 1$, $i$, and $i+1$ as shown in Figure~\ref{fig:rounds}. In round $i-1$, the algorithm proceeds to line~\ref{ln:ConditionSimple}, where only one of the following two cases is possible:
	%	\begin{enumerate}
	%		\item \label{case:whp} $b_{i-1} < 2^{i-1}$: Based on Lemma~\ref{lem:whpSimple}, all honest users can connect to Tor with high probability.
	%		
	%		\item $b_{i-1} \geq 2^{i-1}$: The algorithm proceeds to the next round (round $i$) and distributes $w_{i} = 2^{i+1}$ bridges. Consider the following two possible cases:
	%		\begin{enumerate}
	%			\item $i < k$: In order for the algorithm to proceed to the next round, the adversary has to block at least $2^i$ bridges, otherwise Case~\ref{case:whp} happens and all honest users can connect to Tor with high probability. The adversary can memorize the remainder at most $2^i$ bridge addresses to block in future rounds.
	%			
	%			\item $i = k$: Since this is the last round, the adversary can only block less than half of the $2^{k+1}$ bridges distributed in this round. In fact, it can block at most $t$ bridges learned from the current round as well as \[\sum_{j=1}^{k-2} 2^j = 2^{k-1} - 2\] bridges learned (but not blocked) from the previous rounds. Therefore, we find $k$ sufficiently large such that $2^k > t + 2^{k-1} - 2$. This results in $k > \log{(t-2)} + 1$.
	%		\end{enumerate}
	%	\end{enumerate}
	%	Thus, if the algorithm is run for at least $\lfloor\log{(t-2)}\rfloor + 2 = O(\log{t})$ iterations, then with high probability all honest users are guaranteed to be able to connect to Tor.